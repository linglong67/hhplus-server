## 대기열 시스템 설계

### 기존의 대기열
1) DB에 대기열 테이블을 생성해 토큰과 상태값을 관리
   - 부하가 집중되는 콘서트 관련 테이블에 대한 접근을 인터셉터를 통해 조금 더 앞단에서 통제
   - 동시다발적인 트래픽의 유량을 제어할 수 있었으나, 실제로는 대기열 역시 테이블로 관리되고 있어 DB의 부하가 많이 갈 것으로 예상
2) 최대 활성 토큰 개수를 지정하고, 활성 후 30분 또는 결제완료 시점에 만료된 토큰과의 차이만큼 토큰을 활성화 처리 
   - 3초 주기로 토큰 활성화
   - 10초 주기로 활성 후 30분 이상 지난 토큰 만료 처리

### 변경된 대기열
1) Redis를 통한 대기열 및 활성토큰 관리
   - 인터셉터의 역할은 그대로 존재하되 DB 테이블이 아닌 Redis에 저장된 값을 통해 통제
   - 활성 상태의 토큰이 없을 때는 DB에 직접적인 트랜잭션이 발생하지 않으므로, 이전과 비교해 DB 부하가 많이 줄어들 것으로 예상
2) (유의미한 부하 테스트를 진행하지 못해) 방식은 이전과 동일하게 최대 활성 토큰 개수를 지정한 후 만료되는 토큰만큼 추가적으로 활성화 처리
   - 이후 추가적인 부하 테스트 및 리팩토링을 하게 된다면 ``N초에 M명 활성`` 방식 적용 고려(예상) 

### 달라진 점
1) 대기열 관리 방식
   - 기존에는 하나의 테이블에서 매 토큰마다 대기, 활성, 만료의 상태값을 가지고 있고 토큰 활성화, 활성 토큰 검증 등의 동작을 모두 조회 쿼리를 던져서 확인
   - Redis를 사용하면서 ``대기열``과 ``활성 토큰``에 대한 관리를 나누어 보다 효율적인 접근 및 사용이 가능해짐
   - ``대기열`` → Sorted Sets 자료구조, score - 요청시각, value - 토큰
   - ``활성토큰`` → Sets 자료 구조, value - 토큰:활성시각
2) 대기열 순서 조회
   - DB 테이블 사용 시, 마지막 활성 토큰의 id(PK)와 현재 토큰의 id의 차(-)를 통해 순서 계산
   - 대기열을 Redis의 Sorted Sets 자료구조로 관리하면서 ``ZRANK`` 명령어 사용 시 현재 토큰의 순서를 반환해줌

### 기대 효과
- 성능 향상
  - 빠른 읽기/쓰기: 메모리 기반 DB로 읽기/쓰기 속도 향상되어 대기열과 활성 토큰 처리 속도 개선
- 효율적인 대기열 관리
  - Sorted Sets 자료구조를 사용해 시간 기반 우선순위 관리가 용이해짐 
- 확장성
  - 높은 트래픽을 처리할 때 보다 효율적이며 수평적 확장이 가능
- 간단한 구현
  - 이전 방식과 비교해 로직이 단순화됨

### 주의할 점
- 데이터 휘발성
  - 메모리 기반으로 서버 재시작 or 장애 발생 시 손실될 수 있으므로 AOF 등을 사용한 복구 작업을 고려해야함
- 관리 오버헤드
  - Redis를 사용함으로 설치, 구성, 모니터링 등 추가 관리 작업이 필요
- 복잡성 증가
  - 추가 시스템 도입으로 시스템의 복잡성이 다소 증가